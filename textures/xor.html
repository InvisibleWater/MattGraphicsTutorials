<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="x-ua-compatible" content="ie=edge">
    <link rel="stylesheet" href="../style.css">
	<link rel="stylesheet" href="../prism.css">
	<script src="../js/prism.js"></script>
	<title>The XOR Texture</title>
    <script src="../js/ColorConverter.js"></script>
	<script src="../js/prism.js"></script>
</head>
<body>
	<header class="page-header">
		<h1>Matt's Graphics Tutorials</h1>
		<h2>The XOR Texture</h2>
		<h3>Table of Contents</h3>
		<ul>
			<li><a href="#intro">Introduction</a></li>
			<li><a href="#xorTexture">The XOR Texture</a></li>
			<li><a href="#colors">Colors</a></li>
			<li><a href="#others">AND and OR</a></li>
			<li><a href="#conclusion">Conclusion</a></li>
		</ul>

		<a href="../index.html">Return to Index</a>
	</header>
    <h2 id="intro">Introduction</h2>
    <p>The XOR texture is a simple pattern that's very easy to generate. It's useful for testing texture renderers and learning how to generate images.</p>
    
    <p>This page will be shorter than the others, but the XOR texture just can't be left out in a series of texture generation lessons.</p>
    
    <h2 id="xorTexture">The XOR Texture</h2>
    <p>The XOR texture is generated by performing a bitwise XOR operation on the current pixel. The '^' operator in JavaScript is the XOR operator.</p>
    <div class="code-container"><pre><code class="language-javascript line-numbers">var canvas = document.createElement("canvas");
canvas.width = 256;
canvas.height = 256;

var ctx = canvas.getContext("2d");
			
var imageData = ctx.createImageData(canvas.width, canvas.height);
var w = imageData.width;
var h = imageData.height;
			
for (let y = 0; y < h; y++) {
	for (let x = 0; x < w; x++) {
		let id = (y * w + x) * 4;
		let c = x ^ y;
			
		imageData.data[id] = c;
		imageData.data[id+1] = c;
		imageData.data[id+2] = c;
		imageData.data[id+3] = c;
	}
}
			
ctx.putImageData(imageData, 0, 0);
document.body.appendChild(canvas);</code></pre></div>
    <p>And that should be it. If you run it, you'll see something like this:</p>
    <img class="page-image" src="images/basicXOR.png" width=256 height=256>

	<p>There are some things you should keep in mind, though:</p>
	
	<p><strong>1)</strong> The width and height of the canvas should be powers of two. If they aren't, the texture will appear incomplete:</p>
    <img class="page-image" src="images/incorrectXOR.png">
	
    <p><strong>2)</strong> Each value ranges from 0 to 255. The maximum color value generated using each XOR operation is the same as the dimensions of the canvas if they are powers of two. Because of this, if the size of the canvas is smaller than 256x256, you may not get the desired color, as seen in the image on the left. Luckily, this can be corrected by multiplying the XOR-ed value. For example, multiplying the values in a 64x64 XOR texture by 4 will result in the image on the right:</p>
    <img class="page-image" src="images/darkSmallXOR.png">
    <img class="page-image" src="images/brightSmallXOR.png">
	
	<p><strong>3)</strong> On the other hand, if the size of the canvas is larger than 256x256, for example, 512, you'll have to make sure the color is limited to a maximum value of 256. The quickest way to do this is to modulo divide the values by 256, although if you're familiar with multiples of 256, regular division works fine. In any case, creating an XOR texture larger than 256x256 doesn't really increase the quality; if properly configured, it just gives you more XOR texture.</p>
	
	<p>Bitwise XOR operations work by taking the binary value of two integers, iterating through each bit, and evaluating two corresponding bits in each iteration. If both bits are different, it returns 1, but if the bits are the same, it returns 0. In other words, bit A is 1 or bit b is 1, but not both.</p>
	<p>This is visualized in the following truth table:</p>	
	<table style="width:400px; text-align:left;" width=3 height=5 border="1" cellpadding="1" cellspacing="1">
		<tr align="center">
			<th colspan=3>XOR</th>
		</tr>
		<tr>
			<td><em>Bit_a</em></td>
			<td><em>Bit_b</em></td>
			<td><em>Result</em></td>
		</tr>
		<tr>
			<td>0</td>
			<td>0</td>
			<td>0</td>
		</tr>
		<tr>
			<td>0</td>
			<td style="font-weight:bold">1</td>
			<td style="font-weight:bold">1</td>
		</tr>
		<tr>
			<td style="font-weight:bold">1</td>
			<td>0</td>
			<td style="font-weight:bold">1</td>
		</tr>
		<tr>
			<td style="font-weight:bold">1</td>
			<td style="font-weight:bold">1</td>
			<td>0</td>
		</tr>
	</table>
	
	<p>This is done with every bit of the integers, creating many possible values.</p>
	<p>For example, 10 XOR 25 = 19, because in binary 1010 XOR 11001 = 10011.</p>
    <h2 id="colors">Colors</h2>
	<p>You can also apply different colors to your XOR texture by modifying the individual R, G, and B values. For example:</p>
	<div class="code-container"><pre><code class="language-javascript line-numbers">var canvas = document.createElement("canvas");
canvas.width = 256;
canvas.height = 256;

var ctx = canvas.getContext("2d");

var imageData = ctx.createImageData(canvas.width, canvas.height);
var w = imageData.width;
var h = imageData.height;

for (let y = 0; y < h; y++) {
    for (let x = 0; x < w; x++) {
        let id = (y * w + x) * 4;
        let c = x ^ y;

        imageData.data[id] = 255 - c;
        imageData.data[id+1] = c % 128;
        imageData.data[id+2] = c / 2;
        imageData.data[id+3] = c;
    }
}

ctx.putImageData(imageData, 0, 0);
document.body.appendChild(canvas);</code></pre></div>
	<img class="page-image" src="images/coloredXOR.png">

    <p>Using HSV for the color instead of RGB also produces some interesting results:</p>
	<div class="code-container"><pre><code class="language-javascript line-numbers">var canvas = document.createElement("canvas");
canvas.width = 256;
canvas.height = 256;

var ctx = canvas.getContext("2d");

var imageData = ctx.createImageData(canvas.width, canvas.height);
var w = imageData.width;
var h = imageData.height;

for (let y = 0; y < h; y++) {
    for (let x = 0; x < w; x++) {
        let id = (y * w + x) * 4;
        let c = hsvToRgb((x ^ y) / 256, 1, 1);

        imageData.data[id] = c;
        imageData.data[id+1] = c;
        imageData.data[id+2] = c;
        imageData.data[id+3] = c;
    }
}

ctx.putImageData(imageData, 0, 0);
document.body.appendChild(canvas);</code></pre></div>
	<img class="page-image" src="images/HSVXOR.png">

    <h2 id="others">AND and OR</h2>
    <p>The AND and OR operators generate similar patterns.</p>
	
	<p>The XOR operator returns 1 if both bits are different.</p>
	<table style="width:400px; text-align:left;" width=3 height=5 border="1" cellpadding="1" cellspacing="1">
		<tr align="center">
			<th colspan=3>XOR</th>
		</tr>
		<tr>
			<td><em>Bit_a</em></td>
			<td><em>Bit_b</em></td>
			<td><em>Result</em></td>
		</tr>
		<tr>
			<td>0</td>
			<td>0</td>
			<td>0</td>
		</tr>
		<tr>
			<td>0</td>
			<td style="font-weight:bold">1</td>
			<td style="font-weight:bold">1</td>
		</tr>
		<tr>
			<td style="font-weight:bold">1</td>
			<td>0</td>
			<td style="font-weight:bold">1</td>
		</tr>
		<tr>
			<td style="font-weight:bold">1</td>
			<td style="font-weight:bold">1</td>
			<td>0</td>
		</tr>
	</table>
	
	<p>The AND operator returns 1 if, and only if, both bits are 1. (bit a AND bit b are true)</p>
	<table style="width:400px; text-align:left;" width=3 height=5 border="1" cellpadding="1" cellspacing="1">
		<tr align="center">
			<th colspan=3>AND</th>
		</tr>
		<tr>
			<td><em>Bit_a</em></td>
			<td><em>Bit_b</em></td>
			<td><em>Result</em></td>
		</tr>
		<tr>
			<td>0</td>
			<td>0</td>
			<td>0</td>
		</tr>
		<tr>
			<td>0</td>
			<td style="font-weight:bold">1</td>
			<td style="font-weight:bold">1</td>
		</tr>
		<tr>
			<td style="font-weight:bold">1</td>
			<td>0</td>
			<td style="font-weight:bold">1</td>
		</tr>
		<tr>
			<td style="font-weight:bold">1</td>
			<td style="font-weight:bold">1</td>
			<td>0</td>
		</tr>
	</table>
	
	<p>The OR operator returns 1 if any or both bits are 1. (bit a OR bit b are true)</p>
	<table style="width:400px; text-align:left;" width=3 height=5 border="1" cellpadding="1" cellspacing="1">
		<tr align="center">
			<th colspan=3>OR</th>
		</tr>
		<tr>
			<td><em>Bit_a</em></td>
			<td><em>Bit_b</em></td>
			<td><em>Result</em></td>
		</tr>
		<tr>
			<td>0</td>
			<td>0</td>
			<td>0</td>
		</tr>
		<tr>
			<td>0</td>
			<td style="font-weight:bold">1</td>
			<td style="font-weight:bold">1</td>
		</tr>
		<tr>
			<td style="font-weight:bold">1</td>
			<td>0</td>
			<td style="font-weight:bold">1</td>
		</tr>
		<tr>
			<td style="font-weight:bold">1</td>
			<td style="font-weight:bold">1</td>
			<td>0</td>
		</tr>
	</table>
	
	<p>The AND operator is denoted '&' in JavaScript, and the OR operator '|', replace the '^' operator in your code with one of these to use the new operators. Here are the results of generating patterns with XOR, AND, and OR, respectively:</p>
    <img class="page-image" src="images/basicXOR.png" width=256 height=256>
    <img class="page-image" src="images/basicAND.png" width=256 height=256>
    <img class="page-image" src="images/basicOR.png" width=256 height=256>
	
	<p>As you can clearly see, the AND texture is darker than the others, since the AND operator returns 1 in only one case, making higher color values rare. Meanwhile, the OR operator returns 1 very often, so the resulting texture from it is brighter.</p>
	<h2 id="conclusion">Conclusion</h2>
	<p>In this lesson, it was shown how easy it was to generate an XOR texture, making it great for testing texture renderers.</p>

	<p>In this image, an XOR texture was used to test a basic tunnel effect.</p>
	<img class="page-image" src="images/xor_in_action.png"/>
</body>
</html>
